#include "hal_data.h"
#define BUFFER_SIZE 32  // 수신 버퍼 크기
#define CENTER 320

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


void delay(int ms){
    R_BSP_SoftwareDelay(ms, BSP_DELAY_UNITS_MILLISECONDS);
}

void remove_newline(uint8_t *buffer)
{
    for (int i = 0; buffer[i] != '\0'; i++)
    {
        if (buffer[i] == '\n' || buffer[i] == '\r')  // '\n' 또는 '\r'이면 제거
        {
            buffer[i] = '\0';
            break;  // 첫 번째 제어 문자만 제거하고 나머지는 무시
        }
    }
}


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    init(0x6f);
    //PWM(0x6f);
    setPWMFreq(60);
    Mid();
    delay(10);
    int current_speed = 100;
    int current_angle = CENTER;

    setSpeed(current_speed);

    fsp_err_t err = FSP_SUCCESS;
    uint8_t tx_data[] = "Hello from RA6E1!\r\n";  // 초기 전송 메시지
    uint8_t rx_buffer[BUFFER_SIZE] = {0};        // 수신할 데이터 저장
    uint32_t bytes_to_read = BUFFER_SIZE;        // 수신할 데이터 크기

    while (1)
    {
        // UART 데이터 수신 (폴링 방식)
        err = R_SCI_UART_Read(&g_uart0_ctrl, rx_buffer, bytes_to_read);
        if (err == FSP_SUCCESS)
        {
            remove_newline(rx_buffer);  // 제어 문자 제거

            // 명령 확인 (수신된 문자열이 "SEND"인지 체크)
            if (strstr((char *)rx_buffer, "SEND") != NULL)  // "SEND" 명령 확인
            {
                // 송신 (응답 메시지 전송)
                R_SCI_UART_Write(&g_uart0_ctrl, tx_data, sizeof(tx_data) - 1);
            }

            else if (strstr((char *)rx_buffer, "FW") != NULL)
            {
                Forward();
            }
            else if (strstr((char *)rx_buffer, "BW") != NULL)
            {
                Backward();
            }
            else if (strstr((char *)rx_buffer, "LEBTN") != NULL)
            {
                LeftBtn(&current_angle);
            }
            else if (strstr((char *)rx_buffer, "RIBTN") != NULL)
            {
                RightBtn(&current_angle);
            }

            else if (strstr((char *)rx_buffer, "LE") != NULL)
            {
                char *ptr = (char *)rx_buffer;
                char *endptr;
                uint32_t value = 0;

                // "LE" 명령 확인 후 숫자 파싱
                ptr += 2;
                while (*ptr == ' ') ptr++;
                value = strtol(ptr, &endptr, 10);

                // 유효한 숫자인지 확인
                if (endptr != ptr && value > 0)
                {
                    Left(&current_angle, value);  // 파싱한 값을 Left 함수에 전달
                }
                else
                {
                    uint8_t error_msg[] = "Invalid LE command!\r\n";
                    R_SCI_UART_Write(&g_uart0_ctrl, error_msg, sizeof(error_msg) - 1);
                }
            }
            else if (strstr((char *)rx_buffer, "RI") != NULL)
            {
                char *ptr = (char *)rx_buffer;
                char *endptr;
                uint32_t value = 0;

                // "RI" 명령 확인 후 숫자 파싱
                ptr += 2;
                while (*ptr == ' ') ptr++;
                value = strtol(ptr, &endptr, 10);

                // 유효한 숫자인지 확인
                if (endptr != ptr && value > 0)
                {
                    Right(&current_angle, value);  // 파싱한 값을 Right 함수에 전달
                }
                else
                {
                    uint8_t error_msg[] = "Invalid RI command!\r\n";
                    R_SCI_UART_Write(&g_uart0_ctrl, error_msg, sizeof(error_msg) - 1);
                }
            }

            else if (strstr((char *)rx_buffer, "VE") != NULL)
            {
                char *ptr = (char *)rx_buffer;
                char *endptr;
                uint32_t value = 0;

                // "VE" 명령 확인 후 숫자 파싱
                ptr += 2;  // "VE" 이후로 포인터 이동
                while (*ptr == ' ') ptr++;  // 공백 스킵

                // 숫자 파싱
                value = strtol(ptr, &endptr, 10);

                // 유효한 숫자인지 확인
                if (endptr != ptr && value > 0 && value <= 300)
                {
                    setSpeed(value);
                    current_speed = value;
                }
                else
                {
                    uint8_t error_msg[] = "Invalid VE command or speed out of range!\r\n";
                    R_SCI_UART_Write(&g_uart0_ctrl, error_msg, sizeof(error_msg) - 1);
                }
            }

            else if (strstr((char *)rx_buffer, "MID") != NULL)
            {
                Mid(&current_angle);
            }
            else if (strstr((char *)rx_buffer, "QU") != NULL)
            {
                Release();
            }
            memset(rx_buffer, 0, BUFFER_SIZE);
        }

        // 짧은 지연 (폴링 간격)
        delay(10);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);
        R_IIC_MASTER_Open(&g_i2c_master0_ctrl, &g_i2c_master0_cfg);
        R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    }
}

